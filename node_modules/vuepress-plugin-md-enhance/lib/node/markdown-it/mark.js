"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Insert each marker as a separate text token, and add it to delimiter list
 *
 */
const tokenize = (state, silent) => {
    const start = state.pos;
    const marker = state.src.charCodeAt(start);
    if (silent)
        return false;
    if (marker !== 0x3d /* = */)
        return false;
    const char = String.fromCharCode(marker);
    const scanned = state.scanDelims(state.pos, true);
    let { length } = scanned;
    if (length < 2)
        return false;
    let token;
    if (length % 2) {
        token = state.push("text", "", 0);
        token.content = char;
        length -= 1;
    }
    for (let i = 0; i < length; i += 2) {
        token = state.push("text", "", 0);
        token.content = `${char}${char}`;
        if (scanned.can_open || scanned.can_close)
            state.delimiters.push({
                marker,
                length: 0,
                jump: i,
                token: state.tokens.length - 1,
                end: -1,
                open: scanned.can_open,
                close: scanned.can_close,
            });
    }
    state.pos += scanned.length;
    return true;
};
/*
 * Walk through delimiter list and replace text tokens with tags
 *
 */
const postProcess = (state, delimiters) => {
    let i;
    let j;
    let startDelim;
    let endDelim;
    let token;
    const loneMarkers = [];
    const max = delimiters.length;
    for (i = 0; i < max; i++) {
        startDelim = delimiters[i];
        if (startDelim.marker === 0x3d /* = */ && startDelim.end !== -1) {
            endDelim = delimiters[startDelim.end];
            token = state.tokens[startDelim.token];
            token.type = "mark_open";
            token.tag = "mark";
            token.nesting = 1;
            token.markup = "==";
            token.content = "";
            token = state.tokens[endDelim.token];
            token.type = "mark_close";
            token.tag = "mark";
            token.nesting = -1;
            token.markup = "==";
            token.content = "";
            if (state.tokens[endDelim.token - 1].type === "text" &&
                state.tokens[endDelim.token - 1].content === "=")
                loneMarkers.push(endDelim.token - 1);
        }
    }
    /*
     * If a marker sequence has an odd number of characters, itâ€™s splitted
     * like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the
     * start of the sequence.
     *
     * So, we have to move all those markers after subsequent s_close tags.
     *
     */
    while (loneMarkers.length) {
        i = loneMarkers.pop();
        j = i + 1;
        while (j < state.tokens.length && state.tokens[j].type === "mark_close")
            j += 1;
        j -= 1;
        if (i !== j) {
            token = state.tokens[j];
            state.tokens[j] = state.tokens[i];
            state.tokens[i] = token;
        }
    }
};
const mark = (md) => {
    md.inline.ruler.before("emphasis", "mark", tokenize);
    md.inline.ruler2.before("emphasis", "mark", (state) => {
        const tokensMeta = state.tokens_meta || [];
        postProcess(state, state.delimiters);
        for (let curr = 0; curr < tokensMeta.length; curr++)
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            if (tokensMeta[curr] && tokensMeta[curr].delimiters)
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                postProcess(state, tokensMeta[curr].delimiters);
        return true;
    });
};
exports.default = mark;
//# sourceMappingURL=mark.js.map